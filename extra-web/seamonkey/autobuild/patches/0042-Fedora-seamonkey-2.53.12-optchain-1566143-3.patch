#
#  The core part of backporting support for optional chaining to SeaMonkey 2.53.11
#
#  Totally rewritten, based on bug 1566143 part 3.
#
#  Note: all the testing stuff is omitted for simlicity.
#
#  Includes:
#
#    bug 1566143 part 3  (a core part, need to be totally rewritten)
#    bug 1611777 part 1, part 2
#    bug 1611777 part 4 (without ReflectParse stuff, see it later)
#    bug 1611777 parts 5 to 16
#    bug 1617168
#    bug 1633683
#    bug 1644839
#    bug 1650340
#    bug 1685260
#

#
#  The total stuff for SeaMonkey-2.53.12 optional chaining support includes:
#
#    optchain-1378808  (kinda milestone, introduces emitArguments() and other useful stuff)
#    optchain-1409257
#    optchain-1466000-1
#    optchain-1566143-1to2
#    optchain-1566143-3  (this one)
#    optchain-1610447    (complete changes for ReflectParse stuff)
#


diff -Nrup mozilla/js/src/frontend/BytecodeEmitter.cpp mozilla-OK/js/src/frontend/BytecodeEmitter.cpp
--- mozilla/js/src/frontend/BytecodeEmitter.cpp	2022-04-23 02:17:55.622107610 +0300
+++ mozilla-OK/js/src/frontend/BytecodeEmitter.cpp	2022-04-23 02:15:17.885259444 +0300
@@ -1975,6 +1975,121 @@ class MOZ_STACK_CLASS IfThenElseEmitter
 #endif
 };
 
+// OOOEEE start
+
+class MOZ_RAII BytecodeEmitter::OptionalEmitter {
+  private:
+    BytecodeEmitter* bce_;
+
+    BytecodeEmitter::TDZCheckCache tdzCache_;
+
+    // jumptarget for ShortCircuiting code, which has null or undefined values
+    JumpList jumpShortCircuit_;
+
+    // jumpTarget for code that does not shortCircuit
+    JumpList jumpFinish_;
+
+    int32_t initialDepth_;
+
+  public:
+    OptionalEmitter(BytecodeEmitter* bce, int32_t initialDepth)
+        : bce_(bce), tdzCache_(bce), initialDepth_(initialDepth) {}
+
+    enum class Kind {
+        // Requires two values on the stack
+        Reference,
+        // Requires one value on the stack
+        Other
+    };
+
+    bool emitJumpShortCircuit() {
+        MOZ_ASSERT(initialDepth_ + 1 == bce_->stackDepth);
+        IfThenElseEmitter ifEmitter(bce_);
+        if (!bce_->emitPushNotUndefinedOrNull())
+            return false;
+
+        if (!bce_->emit1(JSOP_NOT))
+            return false;
+
+        if (!ifEmitter.emitIf())
+            return false;
+
+        if (!bce_->emitJump(JSOP_GOTO, &jumpShortCircuit_))
+            return false;
+
+        if (!ifEmitter.emitEnd()) {
+            return false;
+        }
+        return true;
+    }
+
+    bool emitJumpShortCircuitForCall() {
+        int32_t depth = bce_->stackDepth;
+        MOZ_ASSERT(initialDepth_ + 2 == depth);
+        if (!bce_->emit1(JSOP_SWAP))
+            return false;
+
+        IfThenElseEmitter ifEmitter(bce_);
+        if (!bce_->emitPushNotUndefinedOrNull())
+            return false;
+
+        if (!bce_->emit1(JSOP_NOT))
+            return false;
+
+        if (!ifEmitter.emitIf())
+            return false;
+
+        if (!bce_->emit1(JSOP_POP))
+            return false;
+
+        if (!bce_->emitJump(JSOP_GOTO, &jumpShortCircuit_))
+            return false;
+
+        if (!ifEmitter.emitEnd())
+            return false;
+
+        bce_->stackDepth = depth;
+
+        if (!bce_->emit1(JSOP_SWAP))
+            return false;
+        return true;
+    }
+
+    // JSOp is the op code to be emitted, Kind is if we are dealing with a
+    // reference (in which case we need two elements on the stack) or other value
+    // (which needs one element on the stack)
+    bool emitOptionalJumpTarget(JSOp op, Kind kind = Kind::Other) {
+
+        // if we get to this point, it means that the optional chain did not short
+        // circuit, so we should skip the short circuiting bytecode.
+        if (!bce_->emitJump(JSOP_GOTO, &jumpFinish_))
+            return false;
+
+        if (!bce_->emitJumpTargetAndPatch(jumpShortCircuit_))
+            return false;
+
+        // reset stack depth to the depth when we jumped
+        bce_->stackDepth = initialDepth_ + 1;
+
+        if (!bce_->emit1(JSOP_POP))
+            return false;
+
+        if (!bce_->emit1(op))
+            return false;
+
+        if (kind == Kind::Reference) {
+            if (!bce_->emit1(op))
+                return false;
+        }
+
+        if (!bce_->emitJumpTargetAndPatch(jumpFinish_))
+            return false;
+        return true;
+    }
+};
+
+// OOOEEE end
+
 class ForOfLoopControl : public LoopControl
 {
     using EmitterScope = BytecodeEmitter::EmitterScope;
@@ -3140,6 +3255,7 @@ BytecodeEmitter::checkSideEffects(ParseN
         return true;
 
       // Watch out for getters!
+      case ParseNodeKind::OptionalDot:
       case ParseNodeKind::Dot:
         MOZ_ASSERT(pn->isArity(PN_BINARY));
         *answer = true;
@@ -3223,6 +3339,7 @@ BytecodeEmitter::checkSideEffects(ParseN
       case ParseNodeKind::DeleteName:
       case ParseNodeKind::DeleteProp:
       case ParseNodeKind::DeleteElem:
+      case ParseNodeKind::DeleteOptionalChain:
         MOZ_ASSERT(pn->isArity(PN_UNARY));
         *answer = true;
         return true;
@@ -3323,6 +3440,7 @@ BytecodeEmitter::checkSideEffects(ParseN
         return checkSideEffects(pn->pn_right, answer);
 
       // More getters.
+      case ParseNodeKind::OptionalElem:
       case ParseNodeKind::Elem:
         MOZ_ASSERT(pn->isArity(PN_BINARY));
         *answer = true;
@@ -3381,6 +3499,7 @@ BytecodeEmitter::checkSideEffects(ParseN
       // Function calls can invoke non-local code.
       case ParseNodeKind::New:
       case ParseNodeKind::Call:
+      case ParseNodeKind::OptionalCall:
       case ParseNodeKind::TaggedTemplate:
       case ParseNodeKind::SuperCall:
         MOZ_ASSERT(pn->isArity(PN_BINARY));
@@ -3395,6 +3514,11 @@ BytecodeEmitter::checkSideEffects(ParseN
         *answer = true;
         return true;
 
+      case ParseNodeKind::OptionalChain:
+        MOZ_ASSERT(pn->isArity(PN_UNARY));
+        *answer = true;
+        return true;
+
       case ParseNodeKind::Pipeline:
         MOZ_ASSERT(pn->isArity(PN_LIST));
         MOZ_ASSERT(pn->pn_count >= 2);
@@ -9251,6 +9375,81 @@ BytecodeEmitter::emitDeleteExpression(Pa
     return emit1(JSOP_TRUE);
 }
 
+// DDD start
+
+bool BytecodeEmitter::emitDeleteOptionalChain(ParseNode* node) {
+    MOZ_ASSERT(node->isKind(ParseNodeKind::DeleteOptionalChain));
+
+    OptionalEmitter oe(this, this->stackDepth);
+
+    ParseNode* kid = node->pn_kid;
+    switch (kid->getKind()) {
+        case ParseNodeKind::Elem:
+        case ParseNodeKind::OptionalElem: {
+            auto* elemExpr = &kid->as<PropertyByValueBase>();
+            if (!emitDeleteElementInOptChain(elemExpr, oe))
+                return false;
+
+            break;
+        }
+        case ParseNodeKind::Dot:
+        case ParseNodeKind::OptionalDot: {
+            auto* propExpr = &kid->as<PropertyAccessBase>();
+            if (!emitDeletePropertyInOptChain(propExpr, oe))
+                return false;
+            break;
+        }
+        default:
+            MOZ_ASSERT_UNREACHABLE("Unrecognized optional delete ParseNodeKind");
+    }
+
+    if (!oe.emitOptionalJumpTarget(JSOP_TRUE))
+        return false;
+
+    return true;
+}
+
+bool BytecodeEmitter::emitDeletePropertyInOptChain(PropertyAccessBase* propExpr,
+                                                           OptionalEmitter& oe) {
+    MOZ_ASSERT_IF(propExpr->is<PropertyAccess>(),
+                  !propExpr->as<PropertyAccess>().isSuper());
+  
+    if (!emitOptionalTree(&propExpr->expression(), oe))
+        return false;
+    if (propExpr->isKind(ParseNodeKind::OptionalDot)) {
+        if (!oe.emitJumpShortCircuit())
+            return false;
+    }
+
+    //  POE.emitDelete, !isSuper
+    JSOp delOp = sc->strict() ? JSOP_STRICTDELPROP : JSOP_DELPROP;
+    return emitAtomOp(propExpr->pn_right, delOp);
+
+}
+
+bool BytecodeEmitter::emitDeleteElementInOptChain(PropertyByValueBase* elemExpr,
+                                                          OptionalEmitter& oe) {
+    MOZ_ASSERT_IF(elemExpr->is<PropertyByValue>(),
+                  !elemExpr->as<PropertyByValue>().isSuper());
+
+    if (!emitOptionalTree(&elemExpr->expression(), oe))
+        return false;
+
+    if (elemExpr->isKind(ParseNodeKind::OptionalElem)) {
+        if (!oe.emitJumpShortCircuit())
+            return false;
+    }
+
+    if (!emitTree(elemExpr->pn_right))
+        return false;
+
+    //  EOE.emitDelete, !isSuper
+    JSOp delOp = sc->strict() ? JSOP_STRICTDELELEM : JSOP_DELELEM;
+    return emitElemOpBase(delOp);
+}
+
+// DDD end
+
 static const char *
 SelfHostedCallFunctionName(JSAtom* name, JSContext* cx)
 {
@@ -9482,6 +9681,113 @@ BytecodeEmitter::isRestParameter(ParseNo
     return false;
 }
 
+// EOCAT start
+
+/* A version of emitCalleeAndThis for the optional cases:
+ *   * a?.()
+ *   * a?.b()
+ *   * a?.["b"]()
+ *   * (a?.b)()
+ *
+ * See emitCallOrNew and emitOptionalCall for more context.
+ */
+bool BytecodeEmitter::emitOptionalCalleeAndThis(ParseNode* callee, ParseNode* call,
+                                                bool isCall, bool isNew,
+                                                OptionalEmitter& oe) {
+    if (!CheckRecursionLimit(cx)) {
+        return false;
+    }
+
+    bool needsThis = !isCall;
+
+    switch (ParseNodeKind kind = callee->getKind()) {
+        case ParseNodeKind::Name: {
+            if (!emitGetName(callee, isCall))
+                return false;
+            break;
+        }
+
+        case ParseNodeKind::OptionalDot: {
+            MOZ_ASSERT(emitterMode != BytecodeEmitter::SelfHosting);
+            OptionalPropertyAccess* prop = &callee->as<OptionalPropertyAccess>();
+            bool isSuper = false;
+
+            if (!emitOptionalDotExpression(prop, isCall, isSuper, oe))
+                return false;
+            break;
+        }
+        case ParseNodeKind::Dot: {
+            MOZ_ASSERT(emitterMode != BytecodeEmitter::SelfHosting);
+            PropertyAccess* prop = &callee->as<PropertyAccess>();
+            bool isSuper = prop->isSuper();
+
+            if (!emitOptionalDotExpression(prop, isCall, isSuper, oe))
+                return false;
+            break;
+        }
+
+        case ParseNodeKind::OptionalElem: {
+            OptionalPropertyByValue* elem = &callee->as<OptionalPropertyByValue>();
+            bool isSuper = false;
+
+            if (!emitOptionalElemExpression(elem, isCall, isSuper, oe))
+                return false;
+            break;
+        }
+        case ParseNodeKind::Elem: {
+            PropertyByValue* elem = &callee->as<PropertyByValue>();
+            bool isSuper = elem->isSuper();
+
+            if (!emitOptionalElemExpression(elem, isCall, isSuper, oe))
+                return false;
+            break;
+        }
+
+        case ParseNodeKind::Function:
+            MOZ_ASSERT(!emittingRunOnceLambda);
+            if (checkRunOnceContext()) {
+                emittingRunOnceLambda = true;
+                if (!emitOptionalTree(callee, oe))
+                    return false;
+                emittingRunOnceLambda = false;
+            } else {
+                if (!emitOptionalTree(callee, oe))
+                    return false;
+            }
+            needsThis = true;
+            break;
+        case ParseNodeKind::OptionalChain: {
+            return emitCalleeAndThisForOptionalChain(callee, call, isCall, isNew);
+            break;
+        }
+
+        default:
+            MOZ_RELEASE_ASSERT(kind != ParseNodeKind::SuperBase);
+
+            if (!emitOptionalTree(callee, oe))
+                return false;
+
+            needsThis = true;
+            break;
+    }
+
+    if (needsThis) {
+        if (isNew) {
+            if (!emit1(JSOP_IS_CONSTRUCTING)) {
+                return false;
+            }
+        } else {
+            if (!emit1(JSOP_UNDEFINED)) {
+                return false;
+            }
+        }
+    }
+
+    return true;
+}
+
+// EOCAT and
+
 bool
 BytecodeEmitter::emitCalleeAndThis(ParseNode* callee, ParseNode* call, bool isCall, bool isNew)
 {
@@ -9546,6 +9852,9 @@ BytecodeEmitter::emitCalleeAndThis(Parse
         if (!emit1(JSOP_SUPERFUN))
             return false;
         break;
+      case ParseNodeKind::OptionalChain:
+        return emitCalleeAndThisForOptionalChain(callee, call, isCall, isNew);
+        break;
       default:
         if (!emitTree(callee))
             return false;
@@ -9693,6 +10002,89 @@ BytecodeEmitter::emitArguments(ParseNode
     return true;
 }
 
+// EEE start
+
+bool BytecodeEmitter::emitOptionalCall(BinaryNode* node, OptionalEmitter& oe,
+                                       ValueUsage valueUsage) {
+    /*
+     * A modified version of emitCallOrNew that handles optional calls.
+     *
+     * These include the following:
+     *    a?.()
+     *    a.b?.()
+     *    a.["b"]?.()
+     *    (a?.b)?.()
+     *
+     * See CallOrNewEmitter for more context.
+     */
+    ParseNode* pn_callee = node->pn_left;
+    ParseNode* pn_args = node->pn_right;
+    bool isSpread = JOF_OPTYPE(node->getOp()) == JOF_BYTE;
+
+    JSOp op = node->getOp();
+
+    bool isNewOp = op == JSOP_NEW || op == JSOP_SPREADNEW ||
+                   op == JSOP_SUPERCALL || op == JSOP_SPREADSUPERCALL;
+
+    if (!emitOptionalCalleeAndThis(pn_callee, node, /* isCall = */ true, isNewOp, oe))
+        return false;
+
+    if (node->isKind(ParseNodeKind::OptionalCall)) {
+        if (!oe.emitJumpShortCircuitForCall())
+            return false;
+    }
+
+    if (!emitArguments(pn_args, /* isCall = */ true, isSpread))
+        return false;
+
+    uint32_t argc = pn_args->pn_count;
+
+    if (isNewOp) {
+        if (!isSpread) {
+            // Repush the callee as new.target
+            if (!emitDupAt(argc + 1))
+                return false;
+        } else {
+            if (!emitDupAt(2))
+                return false;
+        }
+    }
+
+    ParseNode* coordNode = getCoordNode(node, pn_callee, pn_args);
+
+    if (!isSpread) {
+        if (op == JSOP_CALL && valueUsage == ValueUsage::IgnoreValue) {
+            if (!emitCall(JSOP_CALL_IGNORES_RV, argc, coordNode))
+                return false;
+            checkTypeSet(JSOP_CALL_IGNORES_RV);
+        } else {
+            if (!emitCall(op, argc, coordNode))
+                return false;
+            checkTypeSet(op);
+        }
+    } else {
+        if (coordNode) {
+            if (!updateSourceCoordNotes(coordNode->pn_pos.begin))
+                return false;
+        }
+
+        if (!emit1(op))
+            return false;
+        checkTypeSet(op);
+    }
+    if (op == JSOP_EVAL || op == JSOP_STRICTEVAL ||
+        op == JSOP_SPREADEVAL || op == JSOP_STRICTSPREADEVAL)
+    {
+        uint32_t lineNum = parser.tokenStream().srcCoords.lineNum(node->pn_pos.begin);
+        if (!emitUint32Operand(JSOP_LINENO, lineNum))
+            return false;
+    }
+
+    return true;
+}
+
+// EEE and
+
 bool
 BytecodeEmitter::emitCallOrNew(ParseNode* pn, ValueUsage valueUsage /* = ValueUsage::WantValue */)
 {
@@ -9894,6 +10286,230 @@ BytecodeEmitter::emitLeftAssociative(Par
     return true;
 }
 
+// TTT start
+
+/*
+ * Special `emitTree` for Optional Chaining case.
+ * Examples of this are `emitOptionalChain`, `emitDeleteOptionalChain` and
+ * `emitCalleeAndThisForOptionalChain`.
+ */
+bool BytecodeEmitter::emitOptionalTree(ParseNode* pn, OptionalEmitter& oe,
+                                       ValueUsage valueUsage /* = ValueUsage::WantValue */) {
+    if (!CheckRecursionLimit(cx)) {
+        return false;
+    }
+
+    ParseNodeKind kind = pn->getKind();
+    switch (kind) {
+        case ParseNodeKind::OptionalDot: {
+            OptionalPropertyAccess* prop = &pn->as<OptionalPropertyAccess>();
+            bool isSuper = false;
+            if (!emitOptionalDotExpression(prop, false, isSuper, oe))
+                return false;
+            break;
+        }
+        case ParseNodeKind::Dot: {
+            PropertyAccess* prop = &pn->as<PropertyAccess>();
+            bool isSuper = prop->isSuper();
+            if (!emitOptionalDotExpression(prop, false, isSuper, oe))
+                return false;
+            break;
+        }
+
+        case ParseNodeKind::OptionalElem: {
+            OptionalPropertyByValue* elem = &pn->as<OptionalPropertyByValue>();
+            bool isSuper = false;
+
+            if (!emitOptionalElemExpression(elem, false, isSuper, oe))
+                return false;
+            break;
+        }
+        case ParseNodeKind::Elem: {
+            PropertyByValue* elem = &pn->as<PropertyByValue>();
+            bool isSuper = elem->isSuper();
+
+            if (!emitOptionalElemExpression(elem, false, isSuper, oe))
+                return false;
+            break;
+        }
+
+        case ParseNodeKind::Call:
+        case ParseNodeKind::OptionalCall:
+            if (!emitOptionalCall(&pn->as<BinaryNode>(), oe, valueUsage))
+                return false;
+            break;
+
+        // List of accepted ParseNodeKinds that might appear only at the beginning
+        // of an Optional Chain.
+        // For example, a taggedTemplateExpr node might occur if we have
+        // `test`?.b, with `test` as the taggedTemplateExpr ParseNode.
+        default:
+#ifdef DEBUG
+            // https://tc39.es/ecma262/#sec-primary-expression
+            bool isPrimaryExpression =
+                kind == ParseNodeKind::This || kind == ParseNodeKind::Name ||
+                kind == ParseNodeKind::Null || kind == ParseNodeKind::True ||
+                kind == ParseNodeKind::False ||
+                kind == ParseNodeKind::Number ||
+                kind == ParseNodeKind::BigInt ||
+                kind == ParseNodeKind::String ||
+                kind == ParseNodeKind::Array ||
+                kind == ParseNodeKind::Object ||
+                kind == ParseNodeKind::Function || kind == ParseNodeKind::ClassDecl ||
+                kind == ParseNodeKind::RegExp ||
+                kind == ParseNodeKind::TemplateString ||
+                kind == ParseNodeKind::RawUndefined || pn->isInParens();
+
+            // https://tc39.es/ecma262/#sec-left-hand-side-expressions
+            bool isMemberExpression = isPrimaryExpression ||
+                                      kind == ParseNodeKind::TaggedTemplate ||
+                                      kind == ParseNodeKind::New ||
+                                      kind == ParseNodeKind::NewTarget ||
+                                      kind == ParseNodeKind::ImportMeta;
+
+            bool isCallExpression = kind == ParseNodeKind::SetThis ||
+                                    kind == ParseNodeKind::CallImport;
+
+            MOZ_ASSERT(isMemberExpression || isCallExpression,
+                       "Unknown ParseNodeKind for OptionalChain");
+#endif
+            return emitTree(pn);
+    }
+    return true;
+}
+
+// Handle the case of a call made on a OptionalChainParseNode.
+// For example `(a?.b)()` and `(a?.b)?.()`.
+bool BytecodeEmitter::emitCalleeAndThisForOptionalChain(ParseNode* optionalChain,
+                                                        ParseNode* callNode,
+                                                        bool isCall, bool isNew) {
+    ParseNode* calleeNode = optionalChain->pn_kid;
+
+    // Create a new OptionalEmitter, in order to emit the right bytecode
+    // in isolation.
+    OptionalEmitter oe(this, this->stackDepth);
+
+    if (!emitOptionalCalleeAndThis(calleeNode, callNode, isCall, isNew, oe))
+        return false;
+
+    // complete the jump if necessary. This will set both the "this" value
+    // and the "callee" value to undefined, if the callee is undefined. It
+    // does not matter much what the this value is, the function call will
+    // fail if it is not optional, and be set to undefined otherwise.
+    if (!oe.emitOptionalJumpTarget(JSOP_UNDEFINED, OptionalEmitter::Kind::Reference)) {
+        //              [stack] # If shortcircuit
+        //              [stack] UNDEFINED UNDEFINED
+        //              [stack] # otherwise
+        //              [stack] CALLEE THIS
+        return false;
+    }
+    return true;
+}
+
+bool BytecodeEmitter::emitOptionalChain(ParseNode* node, ValueUsage valueUsage) {
+    ParseNode* expr = node->pn_kid;
+
+    OptionalEmitter oe(this, this->stackDepth);
+
+    if (!emitOptionalTree(expr, oe, valueUsage))
+        return false;
+
+    if (!oe.emitOptionalJumpTarget(JSOP_UNDEFINED)) {
+        //              [stack] # If shortcircuit
+        //              [stack] UNDEFINED
+        //              [stack] # otherwise
+        //              [stack] VAL
+        return false;
+    }
+
+    return true;
+}
+
+bool BytecodeEmitter::emitOptionalDotExpression(PropertyAccessBase* prop,
+                                                bool isCall, bool isSuper,
+                                                OptionalEmitter& oe) {
+    if (isSuper) {
+        UnaryNode* base = &prop->expression().as<UnaryNode>();
+        if (!emitGetThisForSuperBase(base))
+            return false;
+    } else {
+        if (!emitOptionalTree(&prop->expression(), oe))
+            return false;
+    }
+
+    if (prop->isKind(ParseNodeKind::OptionalDot)) {
+        MOZ_ASSERT(!isSuper);
+        if (!oe.emitJumpShortCircuit())
+            return false;
+    }
+
+    //  POE.emitGet
+    if (isCall && !emit1(JSOP_DUP))
+        return false;
+
+    if (isSuper && !emit1(JSOP_SUPERBASE))
+        return false;
+
+    JSOp op;
+    if (isSuper)
+        op = JSOP_GETPROP_SUPER;
+    else
+        op = isCall ? JSOP_CALLPROP : JSOP_GETPROP;
+
+    if (!emitAtomOp(prop->pn_right, op))
+        return false;
+
+    if (isCall && !emit1(JSOP_SWAP))
+        return false;
+
+    return true;
+}
+
+bool BytecodeEmitter::emitOptionalElemExpression(PropertyByValueBase* elem,
+                                                 bool isCall, bool isSuper,
+                                                 OptionalEmitter& oe) {
+    if (isSuper) {
+        UnaryNode* base = &elem->expression().as<UnaryNode>();
+        if (!emitGetThisForSuperBase(base))
+            return false;
+    } else {
+        if (!emitOptionalTree(&elem->expression(), oe))
+            return false;
+    }
+
+    if (elem->isKind(ParseNodeKind::OptionalElem)) {
+        MOZ_ASSERT(!isSuper);
+        if (!oe.emitJumpShortCircuit())
+            return false;
+    }
+
+    //  EOE.prepareForKey
+    if (isCall && !emit1(JSOP_DUP))
+        return false;
+
+    if (!emitTree(elem->pn_right))
+        return false;
+
+    if (isSuper && !emit1(JSOP_SUPERBASE))
+            return false;
+
+    JSOp op;
+    if (isSuper)
+        op = JSOP_GETELEM_SUPER;
+    else
+        op = isCall ? JSOP_CALLELEM : JSOP_GETELEM;
+
+    if (!emitElemOpBase(op))
+        return false;
+
+    if (isCall && !emit1(JSOP_SWAP))
+            return false;
+
+    return true;
+}
+
+// TTT end
+
 bool
 BytecodeEmitter::emitShortCircuit(ParseNode* pn)
 {
@@ -11310,6 +11926,16 @@ BytecodeEmitter::emitTree(ParseNode* pn,
             return false;
         break;
 
+      case ParseNodeKind::DeleteOptionalChain:
+        if (!emitDeleteOptionalChain(pn))
+          return false;
+        break;
+  
+      case ParseNodeKind::OptionalChain:
+        if (!emitOptionalChain(pn, valueUsage))
+          return false;
+        break;
+
       case ParseNodeKind::Dot:
         if (pn->as<PropertyAccess>().isSuper()) {
             if (!emitSuperPropOp(pn, JSOP_GETPROP_SUPER))
diff -Nrup mozilla/js/src/frontend/BytecodeEmitter.h mozilla-OK/js/src/frontend/BytecodeEmitter.h
--- mozilla/js/src/frontend/BytecodeEmitter.h	2022-04-23 02:17:55.623107603 +0300
+++ mozilla-OK/js/src/frontend/BytecodeEmitter.h	2022-04-23 02:05:46.217433961 +0300
@@ -178,6 +178,7 @@ struct MOZ_STACK_CLASS BytecodeEmitter
     class TDZCheckCache;
     class NestableControl;
     class EmitterScope;
+    class OptionalEmitter;
 
     SharedContext* const sc;      /* context shared between parsing and bytecode generation */
 
@@ -477,6 +478,9 @@ struct MOZ_STACK_CLASS BytecodeEmitter
     MOZ_MUST_USE bool emitTree(ParseNode* pn, ValueUsage valueUsage = ValueUsage::WantValue,
                                EmitLineNumberNote emitLineNote = EMIT_LINENOTE);
 
+    MOZ_MUST_USE bool emitOptionalTree(ParseNode* pn, OptionalEmitter& oe,
+                                       ValueUsage valueUsage = ValueUsage::WantValue);
+
     // Emit code for the tree rooted at pn with its own TDZ cache.
     MOZ_MUST_USE bool emitTreeInBranch(ParseNode* pn,
                                        ValueUsage valueUsage = ValueUsage::WantValue);
@@ -801,6 +805,28 @@ struct MOZ_STACK_CLASS BytecodeEmitter
     MOZ_MUST_USE bool emitDeleteElement(ParseNode* pn);
     MOZ_MUST_USE bool emitDeleteExpression(ParseNode* pn);
 
+    // Optional methods which emit Optional Jump Target
+    MOZ_MUST_USE bool emitOptionalChain(ParseNode* pn, ValueUsage valueUsage);
+    MOZ_MUST_USE bool emitCalleeAndThisForOptionalChain(ParseNode* optionalChain,
+                                                        ParseNode* callNode,
+                                                        bool isCall, bool isNew);
+    MOZ_MUST_USE bool emitDeleteOptionalChain(ParseNode* pn);
+  
+    // Optional methods which emit a shortCircuit jump. They need to be called by
+    // a method which emits an Optional Jump Target, see below.
+    MOZ_MUST_USE bool emitOptionalDotExpression(PropertyAccessBase* prop,
+                                                bool isCall, bool isSuper,
+                                                OptionalEmitter& oe);
+    MOZ_MUST_USE bool emitOptionalElemExpression(PropertyByValueBase* elem,
+                                                 bool isCall, bool isSuper,
+                                                 OptionalEmitter& oe);
+    MOZ_MUST_USE bool emitOptionalCall(BinaryNode* callNode, OptionalEmitter& oe,
+                                       ValueUsage valueUsage);
+    MOZ_MUST_USE bool emitDeletePropertyInOptChain(PropertyAccessBase* propExpr,
+                                                   OptionalEmitter& oe);
+    MOZ_MUST_USE bool emitDeleteElementInOptChain(PropertyByValueBase* elemExpr,
+                                                  OptionalEmitter& oe);
+
     // |op| must be JSOP_TYPEOF or JSOP_TYPEOFEXPR.
     MOZ_MUST_USE bool emitTypeof(ParseNode* node, JSOp op);
 
@@ -874,6 +900,10 @@ struct MOZ_STACK_CLASS BytecodeEmitter
     MOZ_MUST_USE bool emitCalleeAndThis(ParseNode* callee, ParseNode* call,
                                         bool isCall, bool isNew);
 
+    MOZ_MUST_USE bool emitOptionalCalleeAndThis(ParseNode* callee, ParseNode* call,
+                                                bool isCall, bool isNew,
+                                                OptionalEmitter& oe);
+
     MOZ_MUST_USE bool emitPipeline(ParseNode* pn);
 
     MOZ_MUST_USE bool emitExportDefault(ParseNode* pn);
diff -Nrup mozilla/js/src/frontend/FoldConstants.cpp mozilla-OK/js/src/frontend/FoldConstants.cpp
--- mozilla/js/src/frontend/FoldConstants.cpp	2022-04-23 02:17:55.624107596 +0300
+++ mozilla-OK/js/src/frontend/FoldConstants.cpp	2022-04-23 02:05:46.218433953 +0300
@@ -369,6 +369,10 @@ ContainsHoistedDeclaration(JSContext* cx
       case ParseNodeKind::Elem:
       case ParseNodeKind::Arguments:
       case ParseNodeKind::Call:
+      case ParseNodeKind::OptionalChain:
+      case ParseNodeKind::OptionalDot:
+      case ParseNodeKind::OptionalElem:
+      case ParseNodeKind::OptionalCall:
       case ParseNodeKind::Name:
       case ParseNodeKind::TemplateString:
       case ParseNodeKind::TemplateStringList:
@@ -828,6 +832,13 @@ FoldAndOrCoalesce(JSContext* cx, ParseNo
     // its element.
     if (node->pn_count == 1) {
         ParseNode* first = node->pn_head;
+
+        //  TryReplaceNode()
+        if (!first)
+            return false;
+
+        first->setInParens((*nodePtr)->isInParens());
+        first->setDirectRHSAnonFunction((*nodePtr)->isDirectRHSAnonFunction());
         ReplaceNode(nodePtr, first);
     }
 
@@ -1278,7 +1289,7 @@ FoldElement(JSContext* cx, ParseNode** n
 {
     ParseNode* node = *nodePtr;
 
-    MOZ_ASSERT(node->isKind(ParseNodeKind::Elem));
+    MOZ_ASSERT(node->isKind(ParseNodeKind::Elem) || node->isKind(ParseNodeKind::OptionalElem));
     MOZ_ASSERT(node->isArity(PN_BINARY));
 
     ParseNode*& expr = node->pn_left;
@@ -1482,6 +1493,7 @@ FoldCall(JSContext* cx, ParseNode* node,
          bool inGenexpLambda)
 {
     MOZ_ASSERT(node->isKind(ParseNodeKind::Call) ||
+               node->isKind(ParseNodeKind::OptionalCall) ||
                node->isKind(ParseNodeKind::SuperCall) ||
                node->isKind(ParseNodeKind::New) ||
                node->isKind(ParseNodeKind::TaggedTemplate));
@@ -1576,13 +1588,14 @@ static bool
 FoldDottedProperty(JSContext* cx, ParseNode* node, Parser<FullParseHandler, char16_t>& parser,
                    bool inGenexpLambda)
 {
-    MOZ_ASSERT(node->isKind(ParseNodeKind::Dot));
+    MOZ_ASSERT(node->isKind(ParseNodeKind::Dot) || node->isKind(ParseNodeKind::OptionalDot));
     MOZ_ASSERT(node->isArity(PN_BINARY));
 
     // Iterate through a long chain of dotted property accesses to find the
     // most-nested non-dotted property node, then fold that.
     ParseNode** nested = &node->pn_left;
-    while ((*nested)->isKind(ParseNodeKind::Dot)) {
+    while ((*nested)->isKind(ParseNodeKind::Dot) ||
+           (*nested)->isKind(ParseNodeKind::OptionalDot)) {
         MOZ_ASSERT((*nested)->isArity(PN_BINARY));
         nested = &(*nested)->pn_left;
     }
@@ -1788,12 +1801,14 @@ Fold(JSContext* cx, ParseNode** pnp, Par
         return FoldClass(cx, pn, parser, inGenexpLambda);
 
       case ParseNodeKind::Elem:
+      case ParseNodeKind::OptionalElem:
         return FoldElement(cx, pnp, parser, inGenexpLambda);
 
       case ParseNodeKind::Add:
         return FoldAdd(cx, pnp, parser, inGenexpLambda);
 
       case ParseNodeKind::Call:
+      case ParseNodeKind::OptionalCall:
       case ParseNodeKind::New:
       case ParseNodeKind::SuperCall:
       case ParseNodeKind::TaggedTemplate:
@@ -1885,6 +1900,7 @@ Fold(JSContext* cx, ParseNode** pnp, Par
         MOZ_CRASH("unreachable, handled by ::Dot");
 
       case ParseNodeKind::Dot:
+      case ParseNodeKind::OptionalDot:
         return FoldDottedProperty(cx, pn, parser, inGenexpLambda);
 
       case ParseNodeKind::LexicalScope:
@@ -1898,6 +1914,10 @@ Fold(JSContext* cx, ParseNode** pnp, Par
 
       case ParseNodeKind::Limit: // invalid sentinel value
         MOZ_CRASH("invalid node kind");
+
+      case ParseNodeKind::OptionalChain:
+      case ParseNodeKind::DeleteOptionalChain:
+        return true;    //  XXX: ???
     }
 
     MOZ_CRASH("shouldn't reach here");
diff -Nrup mozilla/js/src/frontend/FullParseHandler.h mozilla-OK/js/src/frontend/FullParseHandler.h
--- mozilla/js/src/frontend/FullParseHandler.h	2022-04-23 02:17:55.625107588 +0300
+++ mozilla-OK/js/src/frontend/FullParseHandler.h	2022-04-23 02:05:46.219433946 +0300
@@ -51,6 +51,11 @@ class FullParseHandler
         return node->isKind(ParseNodeKind::Dot) || node->isKind(ParseNodeKind::Elem);
     }
 
+    bool isOptionalPropertyAccess(ParseNode* node) {
+        return node->isKind(ParseNodeKind::OptionalDot) ||
+               node->isKind(ParseNodeKind::OptionalElem);
+    }
+
     bool isFunctionCall(ParseNode* node) {
         // Note: super() is a special form, *not* a function call.
         return node->isKind(ParseNodeKind::Call);
@@ -181,7 +186,7 @@ class FullParseHandler
 
         if (expr->isKind(ParseNodeKind::OptionalChain)) {
           ParseNode* kid = expr->pn_kid;
-          // Handle property deletion explictly. OptionalCall is handled
+          // Handle property deletion explicitly. OptionalCall is handled
           // via DeleteExpr.
           if (kid->isKind(ParseNodeKind::Dot) ||
               kid->isKind(ParseNodeKind::OptionalDot) ||
@@ -945,7 +950,7 @@ class FullParseHandler
     }
 
     PropertyName* maybeDottedProperty(ParseNode* pn) {
-        return pn->is<PropertyAccess>() ? &pn->as<PropertyAccess>().name() : nullptr;
+        return pn->is<PropertyAccessBase>() ? &pn->as<PropertyAccessBase>().name() : nullptr;
     }
     JSAtom* isStringExprStatement(ParseNode* pn, TokenPos* pos) {
         if (JSAtom* atom = pn->isStringExprStatement()) {
diff -Nrup mozilla/js/src/frontend/NameFunctions.cpp mozilla-OK/js/src/frontend/NameFunctions.cpp
--- mozilla/js/src/frontend/NameFunctions.cpp	2022-04-23 02:17:55.520108356 +0300
+++ mozilla-OK/js/src/frontend/NameFunctions.cpp	2022-04-23 02:05:46.219433946 +0300
@@ -431,8 +431,10 @@ class NameResolver
           case ParseNodeKind::DeleteName:
           case ParseNodeKind::DeleteProp:
           case ParseNodeKind::DeleteElem:
+          case ParseNodeKind::DeleteOptionalChain:
           case ParseNodeKind::DeleteExpr:
           case ParseNodeKind::Neg:
+          case ParseNodeKind::OptionalChain:
           case ParseNodeKind::Pos:
           case ParseNodeKind::PreIncrement:
           case ParseNodeKind::PostIncrement:
@@ -495,6 +497,14 @@ class NameResolver
                 return false;
             break;
 
+          case ParseNodeKind::OptionalElem:
+            MOZ_ASSERT(cur->isArity(PN_BINARY));
+            if (!resolve(cur->pn_left, prefix))
+                return false;
+            if (!resolve(cur->pn_right, prefix))
+                return false;
+            break;
+
           case ParseNodeKind::With:
             MOZ_ASSERT(cur->isArity(PN_BINARY));
             if (!resolve(cur->pn_left, prefix))
@@ -754,6 +764,7 @@ class NameResolver
 
           case ParseNodeKind::New:
           case ParseNodeKind::Call:
+          case ParseNodeKind::OptionalCall:
           case ParseNodeKind::SuperCall:
             MOZ_ASSERT(cur->isArity(PN_BINARY));
             if (!resolve(cur->pn_left, prefix))
@@ -809,6 +820,13 @@ class NameResolver
             if (!resolve(cur->pn_left, prefix))
                 return false;
             break;
+
+          case ParseNodeKind::OptionalDot:
+            MOZ_ASSERT(cur->isArity(PN_BINARY));
+
+            if (!resolve(cur->pn_left, prefix))
+                return false;
+            break;
 
           case ParseNodeKind::Label:
             MOZ_ASSERT(cur->isArity(PN_NAME));
diff -Nrup mozilla/js/src/frontend/ParseNode.h mozilla-OK/js/src/frontend/ParseNode.h
--- mozilla/js/src/frontend/ParseNode.h	2022-04-23 02:17:55.625107588 +0300
+++ mozilla-OK/js/src/frontend/ParseNode.h	2022-04-23 02:05:46.220433938 +0300
@@ -1237,11 +1237,6 @@ class PropertyAccessBase : public Binary
     PropertyName& name() const {
         return *pn_u.binary.right->pn_atom->asPropertyName();
     }
-
-    bool isSuper() const {
-        // ParseNodeKind::SuperBase cannot result from any expression syntax.
-        return expression().isKind(ParseNodeKind::SuperBase);
-    }
 };
 
 class PropertyAccess : public PropertyAccessBase
@@ -1258,6 +1253,11 @@ class PropertyAccess : public PropertyAc
       MOZ_ASSERT_IF(match, node.is<PropertyAccessBase>());
       return match;
     }
+
+    bool isSuper() const {
+        // ParseNodeKind::SuperBase cannot result from any expression syntax.
+        return expression().isKind(ParseNodeKind::SuperBase);
+    }
 };
   
 class OptionalPropertyAccess : public PropertyAccessBase {
@@ -1286,16 +1286,16 @@ class PropertyByValueBase : public Parse
         pn_u.binary.right = propExpr;
     }
 
+    ParseNode& expression() const {
+        return *pn_u.binary.left;
+    }
+
     static bool test(const ParseNode& node) {
         bool match = node.isKind(ParseNodeKind::Elem) ||
                      node.isKind(ParseNodeKind::OptionalElem);
         MOZ_ASSERT_IF(match, node.isArity(PN_BINARY));
         return match;
     }
-
-    bool isSuper() const {
-        return pn_left->isKind(ParseNodeKind::SuperBase);
-    }
 };
 
 class PropertyByValue : public PropertyByValueBase {
@@ -1308,6 +1308,10 @@ class PropertyByValue : public PropertyB
       MOZ_ASSERT_IF(match, node.is<PropertyByValueBase>());
       return match;
     }
+
+    bool isSuper() const {
+        return pn_left->isKind(ParseNodeKind::SuperBase);
+    }
 };
 
 class OptionalPropertyByValue : public PropertyByValueBase {
diff -Nrup mozilla/js/src/frontend/Parser.cpp mozilla-OK/js/src/frontend/Parser.cpp
--- mozilla/js/src/frontend/Parser.cpp	2022-04-23 02:17:55.629107560 +0300
+++ mozilla-OK/js/src/frontend/Parser.cpp	2022-04-23 02:05:46.222433924 +0300
@@ -7231,7 +7231,7 @@ Parser<ParseHandler, CharT>::classDefini
     if (hasHeritage) {
         if (!tokenStream.getToken(&tt))
             return null();
-        classHeritage = memberExpr(yieldHandling, TripledotProhibited, tt);
+        classHeritage = optionalExpr(yieldHandling, TripledotProhibited, tt);
         if (!classHeritage)
             return null();
     }
@@ -7978,10 +7978,11 @@ enum class EnforcedParentheses : uint8_t
 
 template <class ParseHandler, typename CharT>
 MOZ_ALWAYS_INLINE typename ParseHandler::Node
-Parser<ParseHandler, CharT>::orExpr(InHandling inHandling, YieldHandling yieldHandling,
+Parser<ParseHandler, CharT>::orExpr(InHandling inHandling,
+                                    YieldHandling yieldHandling,
                                     TripledotHandling tripledotHandling,
                                     PossibleError* possibleError,
-                                    InvokedPrediction invoked /* = PredictUninvoked */)
+                                    InvokedPrediction invoked)
 {
     // Shift-reduce parser for the binary operator part of the JS expression
     // syntax.
@@ -8095,10 +8096,11 @@ Parser<ParseHandler, CharT>::orExpr(InHa
 
 template <class ParseHandler, typename CharT>
 MOZ_ALWAYS_INLINE typename ParseHandler::Node
-Parser<ParseHandler, CharT>::condExpr(InHandling inHandling, YieldHandling yieldHandling,
+Parser<ParseHandler, CharT>::condExpr(InHandling inHandling,
+                                      YieldHandling yieldHandling,
                                       TripledotHandling tripledotHandling,
                                       PossibleError* possibleError,
-                                      InvokedPrediction invoked /* = PredictUninvoked */)
+                                      InvokedPrediction invoked)
 {
     Node condition = orExpr(inHandling, yieldHandling, tripledotHandling, possibleError, invoked);
     if (!condition)
@@ -8433,8 +8435,7 @@ template <class ParseHandler, typename C
 typename ParseHandler::Node
 Parser<ParseHandler, CharT>::optionalExpr(YieldHandling yieldHandling,
                                           TripledotHandling tripledotHandling,
-                                          TokenKind tt, bool allowCallSyntax /* = true */,
-                                          PossibleError* possibleError /* = nullptr */,
+                                          TokenKind tt, PossibleError* possibleError /* = nullptr */,
                                           InvokedPrediction invoked /* = PredictUninvoked */)
 {
     if (!CheckRecursionLimit(context)) {
@@ -8453,7 +8454,7 @@ Parser<ParseHandler, CharT>::optionalExp
         return null();
     }
   
-    if (tt == TokenKind::Eof || tt != TokenKind::OptionalChain) {
+    if (tt != TokenKind::OptionalChain) {
         return lhs;
     }
   
@@ -8508,7 +8509,7 @@ Parser<ParseHandler, CharT>::optionalExp
             if (!nextMember) {
                 return null();
             }
-        } else if (allowCallSyntax && tt == TokenKind::Lp) {
+        } else if (tt == TokenKind::Lp) {
             nextMember = memberCall(tt, lhs, yieldHandling, possibleError);
             if (!nextMember) {
                 return null();
@@ -8522,9 +8523,8 @@ Parser<ParseHandler, CharT>::optionalExp
             break;
         }
     
-        if (nextMember) {
-            lhs = nextMember;
-        }
+        MOZ_ASSERT(nextMember);
+        lhs = nextMember;
     }
   
     return handler.newOptionalChain(begin, lhs);
@@ -8583,7 +8583,7 @@ Parser<ParseHandler, CharT>::unaryExpr(Y
             return null();
 
         uint32_t operandOffset = pos().begin;
-        Node operand = memberExpr(yieldHandling, TripledotProhibited, tt2);
+        Node operand = optionalExpr(yieldHandling, TripledotProhibited, tt2);
         if (!operand || !checkIncDecOperand(operand, operandOffset))
             return null();
 
@@ -8627,7 +8627,7 @@ Parser<ParseHandler, CharT>::unaryExpr(Y
         MOZ_FALLTHROUGH;
 
       default: {
-        Node expr = optionalExpr(yieldHandling, tripledotHandling, tt, /* allowCallSyntax = */ true,
+        Node expr = optionalExpr(yieldHandling, tripledotHandling, tt,
                                  possibleError, invoked);
         if (!expr)
             return null();
@@ -9045,9 +9045,9 @@ template <class ParseHandler, typename C
 typename ParseHandler::Node
 Parser<ParseHandler, CharT>::memberExpr(YieldHandling yieldHandling,
                                         TripledotHandling tripledotHandling,
-                                        TokenKind tt, bool allowCallSyntax /* = true */,
-                                        PossibleError* possibleError /* = nullptr */,
-                                        InvokedPrediction invoked /* = PredictUninvoked */)
+                                        TokenKind tt, bool allowCallSyntax,
+                                        PossibleError* possibleError,
+                                        InvokedPrediction invoked)
 {
     MOZ_ASSERT(anyChars.isCurrentTokenType(tt));
 
@@ -9219,6 +9219,7 @@ Parser<ParseHandler, CharT>::memberPrope
     }
 
     if (optionalKind == OptionalKind::Optional) {
+        MOZ_ASSERT(!handler.isSuperBase(lhs));
         return handler.newOptionalPropertyAccess(lhs, name);
     }
     return handler.newPropertyAccess(lhs, name);
@@ -9242,6 +9243,7 @@ Parser<ParseHandler, CharT>::memberElemA
         return null();
     }
     if (optionalKind == OptionalKind::Optional) {
+        MOZ_ASSERT(!handler.isSuperBase(lhs));
         return handler.newOptionalPropertyByValue(lhs, propExpr, pos().end);
     }
     return handler.newPropertyByValue(lhs, propExpr, pos().end);
@@ -9284,7 +9286,8 @@ Parser<ParseHandler, CharT>::memberCall(
                                                PossibleError* possibleError /* = nullptr */,
                                                OptionalKind optionalKind /* = OptionalKind::NonOptional */)
 {
-    if (options().selfHostingMode && handler.isPropertyAccess(lhs)) {
+    if (options().selfHostingMode && (handler.isPropertyAccess(lhs) ||
+                                      handler.isOptionalPropertyAccess(lhs))) {
         error(JSMSG_SELFHOSTED_METHOD_CALL);
         return null();
     }
@@ -10385,7 +10388,7 @@ typename ParseHandler::Node
 Parser<ParseHandler, CharT>::primaryExpr(YieldHandling yieldHandling,
                                          TripledotHandling tripledotHandling, TokenKind tt,
                                          PossibleError* possibleError,
-                                         InvokedPrediction invoked /* = PredictUninvoked */)
+                                         InvokedPrediction invoked)
 {
     MOZ_ASSERT(anyChars.isCurrentTokenType(tt));
     if (!CheckRecursionLimit(context))
diff -Nrup mozilla/js/src/frontend/Parser.h mozilla-OK/js/src/frontend/Parser.h
--- mozilla/js/src/frontend/Parser.h	2022-04-23 02:17:55.630107552 +0300
+++ mozilla-OK/js/src/frontend/Parser.h	2022-04-23 02:05:46.222433924 +0300
@@ -744,26 +744,22 @@ class Parser final
     Node yieldExpression(InHandling inHandling);
     Node condExpr(InHandling inHandling, YieldHandling yieldHandling,
                   TripledotHandling tripledotHandling,
-                  PossibleError* possibleError,
-                  InvokedPrediction invoked = PredictUninvoked);
+                  PossibleError* possibleError, InvokedPrediction invoked);
     Node orExpr(InHandling inHandling, YieldHandling yieldHandling,
                 TripledotHandling tripledotHandling,
-                PossibleError* possibleError,
-                InvokedPrediction invoked = PredictUninvoked);
+                PossibleError* possibleError, InvokedPrediction invoked);
     Node unaryExpr(YieldHandling yieldHandling, TripledotHandling tripledotHandling,
                    PossibleError* possibleError = nullptr,
                    InvokedPrediction invoked = PredictUninvoked);
     Node optionalExpr(YieldHandling yieldHandling, TripledotHandling tripledotHandling,
-                      TokenKind tt, bool allowCallSyntax = true,
-                      PossibleError* possibleError = nullptr,
+                      TokenKind tt, PossibleError* possibleError = nullptr,
                       InvokedPrediction invoked = PredictUninvoked);
     Node memberExpr(YieldHandling yieldHandling, TripledotHandling tripledotHandling,
-                    TokenKind tt, bool allowCallSyntax = true,
-                    PossibleError* possibleError = nullptr,
-                    InvokedPrediction invoked = PredictUninvoked);
+                    TokenKind tt, bool allowCallSyntax,
+                    PossibleError* possibleError, InvokedPrediction invoked);
     Node primaryExpr(YieldHandling yieldHandling, TripledotHandling tripledotHandling,
                      TokenKind tt, PossibleError* possibleError,
-                     InvokedPrediction invoked = PredictUninvoked);
+                     InvokedPrediction invoked);
     Node exprInParens(InHandling inHandling, YieldHandling yieldHandling,
                       TripledotHandling tripledotHandling, PossibleError* possibleError = nullptr);
 
diff -Nrup mozilla/js/src/frontend/SyntaxParseHandler.h mozilla-OK/js/src/frontend/SyntaxParseHandler.h
--- mozilla/js/src/frontend/SyntaxParseHandler.h	2022-04-23 02:17:55.630107552 +0300
+++ mozilla-OK/js/src/frontend/SyntaxParseHandler.h	2022-04-23 02:05:46.223433917 +0300
@@ -135,6 +135,10 @@ class SyntaxParseHandler
         return node == NodeDottedProperty || node == NodeElement;
     }
 
+    bool isOptionalPropertyAccess(Node node) {
+        return node == NodeOptionalDottedProperty || node == NodeOptionalElement;
+    }
+
     bool isFunctionCall(Node node) {
         // Note: super() is a special form, *not* a function call.
         return node == NodeFunctionCall;
@@ -554,7 +558,7 @@ class SyntaxParseHandler
         // |this|.  It's not really eligible for the funapply/funcall
         // optimizations as they're currently implemented (assuming a single
         // value is used for both retrieval and |this|).
-        if (node != NodeDottedProperty)
+        if (node != NodeDottedProperty && node != NodeOptionalDottedProperty)
             return nullptr;
         return lastAtom->asPropertyName();
     }
diff -Nrup mozilla/js/src/jit/IonControlFlow.cpp mozilla-OK/js/src/jit/IonControlFlow.cpp
--- mozilla/js/src/jit/IonControlFlow.cpp	2022-04-13 21:14:22.000000000 +0300
+++ mozilla-OK/js/src/jit/IonControlFlow.cpp	2022-04-23 02:05:46.223433917 +0300
@@ -295,8 +295,11 @@ ControlFlowGenerator::snoopControlFlow(J
             return processWhileOrForInLoop(sn);
 
           default:
-            // Hard assert for now - make an error later.
-            MOZ_CRASH("unknown goto case");
+            // Partially implemented optional chaining can end up here.
+            // Just leave the script uncompiled.
+
+            // Not implemented yet.
+            return ControlStatus::Abort;
         }
         break;
       }
